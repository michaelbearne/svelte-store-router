import { always, compose, map, when } from 'rambda'
import { writable } from 'svelte/store'
import stringToType from 'utilities/stringToType'
import queryToObject from 'utilities/queryToObject'
import cleanObject from 'utilities/cleanObject'
import objectToQuery from 'utilities/objectToQuery'
import objectToFragment from 'utilities/objectToFragment'
import delayed from 'utilities/delayed'

const hasWindow = typeof window !== 'undefined'
const hasHistory = typeof history !== 'undefined'
const hasLocation = typeof location !== 'undefined'
const subWindow = hasWindow && window !== window.parent

let sideEffect = true
let delay = 0
let queryParse = true
let queryTyped = true
let queryClean = false
let fragmentParse = true
let fragmentTyped = true
let fragmentClean = false

export default class Route {
  constructor({ path = '/', query = {}, fragment = {}} = {}) {
    this.path = path
    this.query = when(always(queryTyped), map(stringToType), query)
    this.fragment = when(always(fragmentTyped), map(stringToType), fragment)
  }

  static fromURL(url) {
    return new Route({
      path: url.pathname,
      query: when(always(queryParse), queryToObject, url.search),
      fragment: when(always(fragmentParse), queryToObject, url.hash)
    })
  }
  
  static fromString(url) {
    try {
      return Route.fromURL(new URL(url))
    } catch {
      return Route.fromObject()
    }
  }

  static fromObject({ path, query, fragment} = {}) {
    return new Route({
      path,
      query,
      fragment
    })
  }

  static toStore() {
    const route = writable(Route.fromString(hasLocation ? window.location : ''))

    if (sideEffect && hasWindow && hasHistory && !subWindow) {
      window.addEventListener('popstate', () => {
        route.set(Route.fromString(window.location))
      })
    
      route.subscribe($route => {
        if ($route.toString() !== Route.fromString(window.location).toString()) {
          delayed(delay, () => {
            history.pushState({}, null, $route.toString())
          })
        }
      })
    }

    return route
  }
  
  toString() {
    const path = this.path

    const query = when(
      always(queryParse),
      compose(
        objectToQuery,
        when(
          always(queryClean),
          cleanObject
        )
      ),
      this.query
    )

    const fragment = when(
      always(fragmentParse),
      compose(
        objectToFragment,
        when(
          always(fragmentClean),
          cleanObject
        )
      ),
      this.fragment
    )

    return `${path}${query}${fragment}`
  }

  static get sideEffect() {
    return sideEffect
  }

  static set sideEffect(value) {
    sideEffect = value
  }

  static get delay() {
    return delay
  }

  static set delay(value) {
    delay = value
  }

  static get queryParse() {
    return queryParse
  }

  static set queryParse(value) {
    queryParse = value
  }
  
  static get queryTyped() {
    return queryTyped
  }
  
  static set queryTyped(value) {
    queryTyped = value
  }
  
  static get queryClean() {
    return queryTyped
  }
  
  static set queryClean(value) {
    queryClean = value
  }

  static get fragmentParse() {
    return fragmentParse
  }
  
  static set fragmentParse(value) {
    fragmentParse = value
  }

  static get fragmentTyped() {
    return fragmentTyped
  }
  
  static set fragmentTyped(value) {
    fragmentTyped = value
  }

  static get fragmentClean() {
    return fragmentClean
  }
  
  static set fragmentClean(value) {
    fragmentClean = value
  }
}